#define ABOUT_HELP    "\
about\n\
\n\
Print information about GPT.\n\
"


#define CD_HELP       "\
cd [<dir>]\n\
\n\
Change/print the current working directory (cwd). If no argument, the cwd is printed.\n\
Otherwise the cwd is changed to <dir>.\n\
"


#define CLEAN_HELP    "\
clean [hash|object|problem|linkmap]\n\
\n\
  clean hash      Clean the hash table for the current problem.\n\
  clean object    Clean the hash table and remove the object code for the current\n\
                  problem.\n\
  clean problem   As 'clean object' but also remove the name of the current problem\n\
                  and the current linkmap.\n\
  clean linkmap   Clean the current linkmap.\n\
\n\
If no argument, 'clean hash' is executed.\n\
"


#define CLEAR_HELP    "\
Clear the screen.\n\
"


#define COMPILE_HELP  "\
compile [<problem>]\n\
\n\
Generate object code for problem <problem>. If <problem> is missing, the problem is\n\
the current problem. If <problem> is missing and there is no current problem, the user\n\
is asked for a problem.\n\
"


#define EXIT_HELP     "\n\
Exit.\n\
"


#define GENERATE_HELP "\
generate (core|graph|policy) [<file>]\n\
\n\
\n\
  generate core [<file>]    Generates a core image of the current non-empty hash table.\n\
                            If there is no current problem or the hash table is empty, \n\
                            nothing is generated. If <file> is missing, the core image \n\
                            is stored in the file '<currentProblem>.core'. Otherwise,  \n\
                            it is stored in <file>.\n\
\n\
  generate graph [<file>]   Generates a graph representation of the policy stored in   \n\
                            the hash table. If there is no current problem, the user   \n\
                            is asked for a problem and a core image (see above). If    \n\
                            there is current problem but the hash table is empty, the  \n\
                            user is asked for a core image. If <file> is missing, the  \n\
                            output is sent to the terminal. Otherwise, it is sent to   \n\
                            <file>.\n\
\n\
  generate hash [<file>]    For debugging purposes. Print the internal hash table.     \n\
                            If there is no current problem, the user is asked for a    \n\
                            problem and a core image (see above). If there is current  \n\
                            problem but the hash table is empty, the user is asked for \n\
                            a core image. If <file> is missing, the output is sent to  \n\
                            the terminal. Otherwise, it is sent to <file>.\n\
\n\
  generate table [<file>]   Generates a tabular representation of the policy stored    \n\
                            in the hash table. If there is no current problem, the     \n\
                            user is asked for a problem and a core image (see above).  \n\
                            If there is current problem but the hash table is empty,   \n\
                            the user is asked for a core image. If <file> is missing,  \n\
                            the output is sent to the terminal. Otherwise, it is sent  \n\
                            to <file>.\n\
"


#define HELP_HELP     "\
help [<command>]\n\
\n\
Prints a brief description of <command> if it is a valid GPT command.\n\
If <command> is missing, print this message. Help is available for\n\
the following commands:\n\
\n\
  about\n\
  cd\n\
  clean\n\
  clear\n\
  compile\n\
  exit\n\
  generate\n\
  help\n\
  linkmap\n\
  load\n\
  parse\n\
  print\n\
  quit\n\
  set\n\
  shell\n\
  solve\n\
  viewer\n\
"


#define LINKMAP_HELP  "\
linkmap [+|-] [<entry>]\n\
\n\
Add (+) or remove (-) <entry> from the current linkmap. The linkmap is\n\
used prior to 'compile' in order to specify additional code that need\n\
to be linked into the object code. The linkmap is passed 'as is' to the\n\
linker. If <entry> is missing, the sign is ignored and the current linkmap\n\
is printed. If the sign is missing, <entry> is added to the linkmap.\n\
"


#define LOAD_HELP     "\
(under construction)\n\
"


#define PARSE_HELP    "\
parse <problem-name> <pddl-file>\n\
\n\
Generate the C/C++ code for <problem-name> from the PDDL file <pddl-file>.\n\
"


#define PRINT_HELP    "\
print action <action-id>\n\
print action@ <belief-id>\n\
print belief [<belief-id>|initial|actions|afteraction <belief-id> <action-id>]\n\
print observation <obs-id>\n\
print state [<state-id>|actions|afteraction <state-id> <action-id>]\n\
\n\
Prints diverse information about the current POMDP model. The first version\n\
prints the symbolic name of an action index. The second prints the best action\n\
in a belief id (pointer). The third prints different data about a belief id:\n\
\n\
  print belief <belief-id>                            Prints a given belief,\n\
\n\
  print belief initial                                Prints the data about\n\
                                                      the initial belief,\n\
\n\
  print belief actions <belief-id>                    Prints the applicable actions\n\
                                                      in the belief, and\n\
\n\
  print belief afteraction <belief-id> <action-id>    Prints the result of\n\
                                                      expanding the belief\n\
                                                      with the action.\n\
\n\
The fouth prints the observation associated with a given index. The last\n\
version prints the contents, available actions and result after an action\n\
for a given state. Since a belief id is a pointer inside memory the result\n\
is unspecified if an invalid pointer is given.\n\
"


#define SET_HELP      "\
set [<variable>] [<value>]\n\
\n\
Set/show the value for different variables. If <variable> and <value> are\n\
missing, the value for all variables are printed. If <value> is missing, \n\
the value for <variable> is setted to its default value. If <variable>\n\
is 'defaults' and <value> is missing, the values for all variables are setted\n\
to their default values. The supported variables are:\n\
\n\
  variable = stoprule\n\
  value    = { real [0..1], off }\n\
  default  = 0.0\n\
\n\
     Specify the stopping rule epsilon value or 'off' if not using stopping rule.\n\
\n\
  variable = epsilon\n\
  value    = real [0..1]\n\
  default  = 0.000001\n\
\n\
     Specify the epsilon value used to compare belief states.\n\
\n\
  variable = cutoff\n\
  value    = { off, integer >= 0 }\n\
  default  = off\n\
\n\
     The cutoff value used to terminate each RTDP-BEL trial.\n\
\n\
  variable = runs\n\
  value    = { integer >= 0 }\n\
  default  = 1\n\
     The number of times to apply the solver.\n\
\n\
  variable = pims\n\
  value    = A ':' separated list of pim triplets [n,l,c]\n\
  default  = [1,1,0]\n\
\n\
     The schedule for a run of the solver. The triplets are executed in order.\n\
     A triplet [n,l,c] instruct the solver to execute l learning trials, then \n\
     c control trials and repeat this n times.\n\
\n\
  variable = discount\n\
  value    = real [0..1]\n\
  default  = 1.0\n\
\n\
     The discount factor for the problem.\n\
\n\
  variable = discretization-levels\n\
  value    = { integer > 0, off }\n\
  default  = 20\n\
\n\
     The number of levels to discretize/quantize the belief states inside\n\
     the RTDP-BEL algorithm. The value 'off' means to use to discretization.\n\
\n\
  variable = qmdp-discount\n\
  value    = real [0..1]\n\
  default  = 1.0\n\
\n\
     The discount factor to use when computing the Qmdp heuristic.\n\
\n\
  variable = incremental-mode\n\
  value    = { on, off }\n\
  default  = off\n\
\n\
     If 'on' the solver computes the model dynamically.\n\
\n\
  variable = heuristic-lookahead\n\
  value    = { integer >= 0 }\n\
  default  = 0\n\
\n\
     The look ahead level for the current heuristic.\n\
\n\
  variable = zero-heuristic\n\
  value    = { on, off }\n\
  default  = off\n\
\n\
     If 'on' the solver uses zero heuristic.\n\
\n\
  variable = random-ties\n\
  value    = { on, off }\n\
  default  = on\n\
\n\
     If 'on' the solver breaks ties in action selection randomly.\n\
\n\
  variable = random-seed\n\
  value    = { integer >= 0 }\n\
  default  = RANDOM\n\
\n\
     Seed for the random number generator.\n\
\n\
  variable = core-level\n\
  value    = { 0, 1, 2, 3 }\n\
  default  = 0\n\
\n\
     For automatic generation of core images. A value of '0' means generates no\n\
     core image. A value of '1' generates core images after each run. A value of\n\
     '2' generates core images after each pim triplet. A value of '3' generates\n\
     core images after each learning trial. A value of '2' only makes sense when\n\
     stoptule is 'off'.\n\
\n\
  variable = output-level\n\
  value    = { 0, 1 }\n\
  default  = 0\n\
\n\
     Control the amount of information printed after each trial. Normally, the output\n\
     for each trial has form:\n\
\n\
        <e=0.029>:<r=1>:<t=c>:<v=9.239>:<l=u>:<i=0>:<f=196>:<s=-1>:<c=-1.000>:<d=-1.00>\n\
\n\
     where the fields are:\n\
\n\
        e = elapsed-time for the trial.\n\
        r = run number.\n\
        t = type of trial; 'l' for learning trial, 'c' for control trial.\n\
        v = current value for the initial belief state.\n\
        l = status for the initial belief state; 'u' for unsolved, 's' for solved.\n\
        i = initial state of the simulator in the trial.\n\
        f = final state of the simulator in the trial.\n\
        s = number of steps in the trial.\n\
        c = total cost for the trial.\n\
        d = total discounted cost for the trial.\n\
\n\
     This is the standard output for output-level equal to '0'. If it is equal to '1',\n\
     an additional 'p' field containing the sequence of steps is printed. Some fields\n\
     may be missing for specific problem types.\n\
\n\
  variable = precision\n\
  value    = { integer >= 0 }\n\
  default  = 6\n\
\n\
     Number of decimal places to be printed.\n\
\n\
  variable = action-cache\n\
  variable = obs-cache\n\
  variable = other-cache\n\
  value    = A pair [size,cluster]. Cluster must be a divisor of size.\n\
  default  = [20240,80]\n\
\n\
      The RTDP-BEL algorithm spends most of the time computing the belief states\n\
      that result after the application of an action, and the one after the action\n\
      and the reception of feedback. Frequent computations are stored in the the\n\
      action-cache and obs-cache respectively in order to save computer time.\n\
      The other-cache is used for the task of computing discretizations.\n\
      The value for this variables don't change the result of the algorithm but\n\
      they may have deep impact in the performance. If the size is zero, then the\n\
      cache is disabled.\n\
\n\
  variable = cc\n\
  value    = Name of the C/C++ compiler.\n\
  default  = g++\n\
\n\
  variable = ccflags\n\
  value    = Flags passed to the C/C++ compiler.\n\
  default  = <empty>\n\
\n\
  variable = ld\n\
  value    = Name of the linker.\n\
  default  = ld\n\
\n\
  variable = ldflags\n\
  value    = Flags passed to the linker needed for creation of shared object.\n\
  default  = -G\n\
\n\
  variable = include-dir\n\
  value    = Search path for include files.\n\
  default  = $GPTHOME/include:.\n\
\n\
  variable = lib-dir\n\
  value    = Search path for libraries.\n\
  default  = $GPTHOME/lib\n\
\n\
  variable = entry-point\n\
  value    = Entry point to problem's object code (don't change).\n\
  default  = (compiler/architecture dependent)\n\
"


#define SHELL_HELP    "\
shell [<command>]\n\
\n\
Execute the command <command> in a UNIX shell. If <command> is missing, the\n\
'ksh' shell is started and GPT is suspended until the shell is terminated.\n\
The 'shell' command may be abbreviated with the character '!'.\n\
"


#define SOLVE_HELP    "\
solve [<problem>] [<file>]\n\
\n\
Solve <problem> with the current options (see 'set') and sent the output to\n\
<file>. This command can only be done after 'compile <problem>'. If <file> is\n\
missing, the output is sent to the file '<problem>.output'. If <file> is '-',\n\
the output is sent to the terminal. If <problem> is missing, the current problem\n\
is solved. if <problem> is missing and there is no current problem,  the user is\n\
asked for a problem.\n\
"


#define VIEWER_HELP   "\
viewer [<file>]\n\
\n\
Start the graph viewer as a background process. The viewer is called with\n\
<file> as argument. This commands needs a session with X support.\n\
"



HELP_MSG("about",ABOUT_HELP)
HELP_MSG("cd",CD_HELP)
HELP_MSG("clean",CLEAN_HELP)
HELP_MSG("clear",CLEAR_HELP)
HELP_MSG("compile",COMPILE_HELP)
HELP_MSG("exit",EXIT_HELP)
HELP_MSG("generate",GENERATE_HELP)
HELP_MSG("help",HELP_HELP)
HELP_MSG("linkmap",LINKMAP_HELP)
HELP_MSG("load",LOAD_HELP)
HELP_MSG("parse",PARSE_HELP)
HELP_MSG("print",PRINT_HELP)
HELP_MSG("quit",EXIT_HELP)
HELP_MSG("set",SET_HELP)
HELP_MSG("shell",SHELL_HELP)
HELP_MSG("solve",SOLVE_HELP)
HELP_MSG("viewer",VIEWER_HELP)
